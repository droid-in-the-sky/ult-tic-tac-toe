#ifndef _ULT_GAME_CEU
#define _ULT_GAME_CEU

#include "sdl.ceu"
#include "colors.ceu"
#include "ui.ceu"
#include "ui-texture.ceu"
#include "ui-grid.ceu"

input void SDL_REDRAW;
input void SDL_QUIT;

#ifdef __ULT_GAME_CEU

interface Global with
    event (void*,int) ok_game;
    var int player;
end
event (void*,int) ok_game;
var int player = 1;

#endif

native pure _Game_check();
native do
    int Game_lay[9] = {
        0, 1, 2,
        3, 4, 5,
        6, 7, 8
    };

    // check win: (-1=tie, 0=going, 1=plr1, 2=plr2
    int Game_check (s8* state, int idx, int plr) {
        int x = idx / 3;
        int y = idx % 3;
        int i;

        for (i=0; i<3; i++) {    // check lin
            int p = x*3 + i;
            if (state[p] != plr)
                break;
            else if (i == 2)
                return plr;
        }

        for (i=0; i<3; i++) {    // check col
            int p = i*3 + y;
            if (state[p] != plr)
                break;
            else if (i == 2)
                return plr;
        }

        if (x == y) {            // check diag
            for (i=0; i<3; i++) {
                int p = i*3 + i;
                if (state[p] != plr)
                    break;
                else if (i == 2)
                    return plr;
            }
        }

        for (i=0; i<3; i++) {    // check anti-diag
            int p = i*3 + 2-i;
            if (state[p] != plr)
                break;
            else if (i == 2)
                return plr;
        }

        for (i=0; i<9; i++) {    // check tie
            if (state[i] == 0)
                break;
            else if (i == 8)
                return -1;
        }

        return 0;
    }
end

class Game with
    var int             id   = -1;
    var int             win? = 0;
    var _SDL_Renderer*  ren  = null;
    var UIGrid*         grid = null;

    event int pse?;
do
    _assert(this.id   >= 0);
    _assert(this.win? == 0);
    _assert(this.ren  != null);

    var s8[9] state;
        loop i, 9 do
            state[i] = 0;
        end

    var UIGrid g with
        this.ren         = ren;
        this.clr_cell_fr = &_colors.black;
        this.clr_ui_bg   = &_colors.white;
        this.pad_x       = 2;
        this.pad_y       = 2;
        this.lay_lins    = 3;
        this.lay_cols    = 3;
        this.lay         = _Game_lay;
        this.uis_n       = 9;
    end;
    this.grid = &g;
    loop i, 9 do
        g.uis[i] = null;
    end

    // images x - o
    var _SDL_Texture* tex_x;
        finalize
            tex_x = _IMG_LoadTexture(ren, "imgs/x.png");
        with
            _SDL_DestroyTexture(tex_x);
        end
    var _SDL_Texture* tex_o;
        finalize
            tex_o = _IMG_LoadTexture(ren, "imgs/o.png");
        with
            _SDL_DestroyTexture(tex_o);
        end

    var UITexture* ui;
    pause/if this.pse? do
        loop do
            var int idx;
            var UI* clk;
            (idx,clk) = await g.ok_uiclicked;

            if clk != null then
                continue;
            end

            state[idx] = global:player;
            this.win?  = _Game_check(state, idx, global:player);

            ui = new[9] UITexture with
                this.ren = ren;
                if global:player == 1 then
                    this.tex = tex_x;
                else
                    this.tex = tex_o;
                end
            end;
            g._go_ui(idx, ui)
                finalize with
                    //g._go_ui(idx, null);
                end;
            // TODO: ui is ptr (error!)
            // but grid lives more than do-end of "new" (no error!)

            // notify main application
            emit global:ok_game => (&this, idx);

            if this.win? then
                await FOREVER;      // TODO: chg to break
            end
        end
    end
end;

#ifdef __ULT_GAME_CEU

var _SDL_Window* win;
    finalize
        win = _SDL_CreateWindow("The Ultimate Tic-Tac-Toe",
                            500, 1300, 800, 480, _SDL_WINDOW_SHOWN);
    with
        _SDL_DestroyWindow(win);
    end

var int win_w;
var int win_h;
    _SDL_GetWindowSize(win, &win_w, &win_h);

var _SDL_Renderer* ren;
    finalize
        ren = _SDL_CreateRenderer(win, -1, 0);
    with
        _SDL_DestroyRenderer(ren);
    end

// images X - O
var _SDL_Texture* tex_xx;
    finalize
        tex_xx = _IMG_LoadTexture(ren, "imgs/xx.png");
    with
        _SDL_DestroyTexture(tex_xx);
    end
var _SDL_Texture* tex_oo;
    finalize
        tex_oo = _IMG_LoadTexture(ren, "imgs/oo.png");
    with
        _SDL_DestroyTexture(tex_oo);
    end

par/or do
    await SDL_QUIT;
with
    loop do
        var Game game with
            this.id  = 0;
            this.ren = ren;
        end;

        var _SDL_Rect r;
            r.w = win_w;
            r.h = win_h;
            r.x = 0;
            r.y = 0;
        game.grid:_go_rect(&r);

        loop do
            var void* oth_;
            var int idx;
            (oth_,idx) = await global:ok_game;
            var Game* oth = (Game*) oth_;
            _assert(oth != null);
//_printf("id=%d win?=%d idx=%d\n", oth:id, oth:win?, idx);

            if oth:win? > 0 then
                break;
            end

            global:player = 3 - global:player;
        end

        var UITexture ui with
            this.ren = ren;
            this.clr_bg = &_colors.gray;
            if global:player == 1 then
                this.tex = tex_xx;
            else
                this.tex = tex_oo;
            end
        end;
        ui._go_rect(&r);

        await game.grid:ok_clicked;
    end
with
    every SDL_REDRAW do
        _SDL_RenderPresent(ren);
    end
end

return 0;

#endif
#endif
