native constant _UI_ALIGN_LEFT, _UI_ALIGN_CENTER, _UI_ALIGN_RIGHT,
                _UI_ALIGN_TOP,  _UI_ALIGN_MIDDLE, _UI_ALIGN_BOTTOM;
native pure _UI_align();
native do
    enum {
        UI_ALIGN_LEFT = 0,
        UI_ALIGN_CENTER,
        UI_ALIGN_RIGHT
    };
    enum {
        UI_ALIGN_TOP = 0,
        UI_ALIGN_MIDDLE,
        UI_ALIGN_BOTTOM,
    };

    int UI_align (int p_out, int dim_out, int dim_in, int align)
    {
        switch (align)
        {
            case UI_ALIGN_LEFT:
            //case UI_ALIGN_TOP:
                return p_out;

            case UI_ALIGN_CENTER:
            //case UI_ALIGN_MIDDLE:
                return p_out + (dim_out - dim_in)/2;

            case UI_ALIGN_RIGHT:
            //case UI_ALIGN_BOTTOM:
                return p_out + (dim_out - dim_in);
        }
    }
end

// TODO:
// macro p/ verificar que go_redim<-draw/move/etc

interface UI with
    event void           ok_redraw_pre;
    event void           ok_redraw_pos;
    event void           ok_clicked;
    event _SDL_Point*    go_move;
    event _SDL_Rect*     go_redim;

    var   _SDL_Renderer* ren;
    var   _SDL_Rect      rect;
    var   int            align_x;
    var   int            align_y;
    var   int            clr_bg?;
    var   _SDL_Color     clr_bg;
end

input void SDL_REDRAW;
input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN;

class UITexture with
    interface UI;
    var   _SDL_Renderer* ren     = null;
    var   _SDL_Texture*  tex     = null;
    var   int            align_x = _UI_ALIGN_CENTER;
    var   int            align_y = _UI_ALIGN_MIDDLE;
    var   int            clr_bg? = 0;
do
    var _SDL_Rect* r = await go_redim;

    _assert(this.tex != null);

    // TODO: check result
    var int w, h;
    _SDL_QueryTexture(tex, null, null, &w, &h);

    var _SDL_Rect rect_out;

    par do
        // GO_REDIM
        loop do
            if r != null then
                rect_out = *r;
            end

            rect.w = w;     // TODO: scale?
            rect.h = h;
            rect.x = _UI_align(rect_out.x, rect_out.w, rect.w, align_x);
            rect.y = _UI_align(rect_out.y, rect_out.h, rect.h, align_y);
            r = await go_redim;
        end
    with
        // GO_MOVE
        loop do
            var _SDL_Point* pt = await go_move;
            rect.x = rect.x + pt:x;
            rect.y = rect.y + pt:y;
            emit go_redim => &rect;
        end
    with
        // OK_CLICKED
        loop do
            var _SDL_MouseButtonEvent* but = await SDL_MOUSEBUTTONDOWN;
            if _SDL_Rect_vs_Mouse(&this.rect, but) then
                emit ok_clicked;
            end
        end
    with
        _assert(this.ren != null);
        every SDL_REDRAW do
            if clr_bg? then
                _SDL_SetRenderDrawColor(ren,
                    clr_bg.r,clr_bg.g,clr_bg.b,clr_bg.a);
                _SDL_RenderFillRect(ren, &rect_out);
            end
            emit ok_redraw_pre;
            _SDL_RenderCopy(this.ren, this.tex, null, &rect);
            emit ok_redraw_pos;
        end
    end
end
